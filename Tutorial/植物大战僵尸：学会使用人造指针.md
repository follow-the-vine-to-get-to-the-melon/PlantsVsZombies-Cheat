通过向游戏中注入一段特殊的汇编代码，实现自动获取动态地址，省略找基址的麻烦。该方法适用于游戏基址层数过多无法直接获取到基址，游戏根本无法找到基址。

<!--more-->

1.打开CE工具并附加游戏进程，首先通过遍历的方式找到阳光的动态地址，然后在地址栏上右键选择`找出是什么改写了这个地址`如下所示我们选择`mov eax,[esi+5560]`这条汇编代码。

![](/image/1379525-20220122090517913-720663956.png)

2.上图可以看到有两条汇编指令，而前面的计数器一直在增加，说明有时钟一直在访问这个地址，我们以第2条汇编指令为例，点击`反汇编当前地址`在XOR指令上按下`F5`下断点，其中`mov eax,[esi+5560]`则表示将当前阳光数量赋值给EAX寄存器，我们可以看到右侧寄存器窗口`eax=32`，其中的32正好就是阳光的十六进制表示形式，注意`mov eax,[esi+5560]`这条指令，观察该指令在注入前与注入后会有什么变化？

![](/image/1379525-20220122090526726-1047044774.png)

3.直接点击`工具列表`-> `选择自动汇编` ->`模版`->`代码注入`-> `确定按钮`，如下图所示：

![](/image/1379525-20220122090534921-1998696937.png)

4.我们需要在`mov eax,[esi+00005560]`这条汇编指令执行之前获取到里面的阳光数据，此时可以在`originalcode`之前写入以下汇编代码，其中`push eax，pop eax`分别是压栈与出栈，因为我们要使用EAX寄存器暂存数据，此时必须要将原始的EAX寄存器里面的内容进行保存，在代码执行完毕以后必须通过POP指令归位，否则会导致程序异常或堆栈失衡，`mov eax,[esi+5560]`则表示将`[esi+5560]`中的数据取出来，此处就是阳光的数量。

![](/image/1379525-20220122090543742-394385017.png)

5.接着我们需要找一个相对固定的内存地址，并将其填充到`mov [xxxx],eax`方框中，此时我们回到CE中(自动汇编窗口不要关闭)，在内存查看器窗口选择`视图`->`内存区域`

![](/image/1379525-20220122090551466-114155477.png)

我们需要浏览内存区域，找出一个具有读写权限的空地址，并且类型为映像的，这里还需要看后面的模块一定要是植物大战僵尸文件里的模块，此处我找到了一个内存地址 `0B4CF000`，双击即可跳转到相应的位置，这里我们不能选择`02CA9000`这个内存地址，因为这个地址是QQ拼音的模块。

![](/image/1379525-20220122090601047-1818814708.png)

6.通过双击`0B4CF000`地址，即跳转到相应的内存区域，如下在内存查看器中，标红处。

![](/image/1379525-20220122090607884-1099345811.png)

我们直接将`0b4cf000`这个内存地址填入到我们的汇编代码中，此时只要程序获取到阳光，会默认将阳光的数量放入0B4CF000这个内存中进行保存。

![](/image/1379525-20220122090614843-592435258.png)

完成获取以后，我们直接在CE中添加这个内存地址，并开启自动汇编CT脚本，此时阳光的数量就可以获取到了。

![](/image/1379525-20220122090623384-1776104791.png)

我们再次来到反汇编窗口观察注入后的变化，可以看到CE是直接在`D6679600`处写入了 jmp 指令直接跳转到了我们自己写的代码中去执行了。

![](/image/1379525-20220122090630279-1172039172.png)

跟随`00DF0000`这个地址即可看到如下代码，没错！这些代码正是我们在CT表中分配的，当执行完获取数据以后则会自动跳转到原始地址`0048982B`继续执行原始代码。

![](/image/1379525-20220122090637071-1127799589.png)

总结：上方的的人造指针有一个小问题，那就是我们无法修改阳光的数量，其实这个问题很简单，在开头我们说过该地址有一个时钟一直在给这个地址赋值，而我们在开头查找的是内存访问，如果要修改数据，应该要找内存写入相关的地址。
