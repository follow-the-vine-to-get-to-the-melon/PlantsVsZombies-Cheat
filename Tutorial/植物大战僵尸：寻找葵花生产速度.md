本次实验内容：通过CE修改器遍历出控制太阳花吐出阳光的时间变量，太阳花吐出阳光是由一个定时器控制的，首先我们找到第一个太阳花的基址与偏移，然后找出第二个太阳花的动态地址，并通过公式计算得到太阳花结构长度的相对偏移，最后我们通过C语言编程实现，遍历并修改所有图中的太阳花吐出阳光的时间，最终实现全图吐阳光。

  从本次实验开始将接触到关于分析定时器的相关技巧，一般的定时器分为递增定时器与递减定时器，不过大多数游戏都会使用递减定时器，因为递减定时器更好编程判断，本游戏中的太阳花生产速度使用的就是递减定时器，太阳花生产阳光一定是一个周期性的事件，我们只要找到该定时器并改写它的时间即可实现无限吐阳光，如下是太阳花定时器的遍历技巧：

  > 首先种下第一个太阳花 \-> 然后CE马上搜索 \-> 未知的初始值  
  > 回到游戏短暂等待\(时钟发生变化\) \-> 然后马上切回CE \-> 搜索减少的数值 \-> 掉一点搜一点  
  > 如果中途太阳花吐出了阳光 \-> 则需要搜索增加的数值\(1次\) \-> 然后再搜索减少的数值  
  > 最终找到一个动态地址\(范围:0-5000\) \-> 锁定该变量范围在1至10即可 \-> 实现无限出阳光

  修改太阳花时钟有两种方式，第一种找到基址与偏移然后分别修改每一个定时器的时钟，第二种方式则是找到汇编跳转并进行改写，第一种方式要找植物相对偏移，首先我们先来猜测以下游戏作者会用什么方式存储不同植物的栏位。

  * * *

  如下图: 我们可先来猜测，游戏作者会使用二维结构体来存储植物位置，通过结构体链表将不同植物进行连接，当我们铲除植物的时候，只需要在链表中摘除相应节点，而太阳花的的地址一定是连续存储在内存中的线性空间，此游戏的矩阵可能就是`5*9`这么一个范围，假设在横坐标X轴如果两个植物之间的相对偏移是14C\(14C就是太阳花结构体的实际长度\)，那么我们找到第一个植物的基址与偏移，每次相加14C的偏移量，则可遍历到下一个植物的内存地址，同理如果相减14C则就可遍历出上一个植物的内存地址，而纵坐标Y可能就是由一个1C偏移来控制的，此时我们也仅仅只是猜测。

  ![](/image/1379525-20191204182714110-1891266882.png)

  如果我们按照上图中的方式进行推理，其计算每一个阳光时钟公式就可总结为如下，但真的是这样吗\?

  > X坐标下的第1个植物：基地址 + 偏移1 + 偏移2 + 768  
  > X坐标下的第2个植物：基地址 + 偏移1 + 偏移2 + 768 + 14C  
  > X坐标下的第3个植物：基地址 + 偏移1 + 偏移2 + 768 + 14C + 14C  
  > Y坐标下的第1个植物：基地址 + 偏移1 + 偏移2 + 768 + 1C  
  > Y坐标下的第2个植物：基地址 + 偏移1 + 偏移2 + 768 + 1C + 14C

  其实并不是！经过我对具体坐标的分析，在本游戏中太阳花与太阳花之间，可能使用了一维结构体来存储的植物与植物之间的属性，每次相加偏移都会遍历到下一个植物的属性上面，也就是说无论太阳花种植到在什么位置，只要相加偏移就可以遍历到下一个植物的冷却数据，而需要遍历的次数则取决于太阳花的种植数量。

  首先我们种植一颗太阳花，并通过上方的遍历技巧找到当前第一个植物的动态地址，排查到最后可发现剩余11条结果，此时我们可猜测这个定时器应该在0-10000之间，应该不会大于这个参数，如下图我找到了`13D65160`这个地址，将该地址锁定为10就可以实现第一个太阳无限吐阳光。

  ![](/image/1379525-20191204182727659-677046252.png)

  接着我们在第一个太阳花的旁边种植第二个太阳花，然后还是使用前面的遍历技巧找到第二个太阳花的动态地址`13D652AC`，找到以后我们可以猜测第一个与第二个在内存中的布局应该是连续的，所以我们可以使用`13D652AC \- 13D65160 = 14C`此处得到的14C其实就是太阳花结构的实际长度，也可以说是两个太阳花之间的偏移值。

  ![](/image/1379525-20191204182740438-117317565.png)

  既然知道了太阳花之间的相对偏移，那么我们下一步就是来找一个固定的地址，我们在第一个太阳花地址上，右键选择查找改写地址，然后可看到`0045FA48 \- 83 47 58 FF \- add dword ptr [edi+58],-01 <<` 这条汇编指令，此汇编指令乍一看是一条加法指令，但其相加的操作数是-1也就是相减，此处就是太阳花的定时器，其每次减1直到为0则吐出阳光，这里我们就可知该定时器是一个递减定时器，我们只需要记下偏移为`58`下一个地址是`13D65108`即可。

  ![](/image/1379525-20191204182753871-2022736937.png)

  回到CE我们继续搜索十六进制地址`13D65108`然后找到偏移为`AC`下一个地址为`13D08948`

  ![](/image/1379525-20191204182802695-271018368.png)

  继续搜索`13D08948`得到下一个偏移数据为`768`,继续搜索`00FE7B80`

  ![](/image/1379525-20191204182818901-1383844314.png)

  最终经过我们的搜索得到了一个绿色的基址`00599F75 \- A1 389F6A00 \- mov eax,[006A9F38] <<`

  ![](/image/1379525-20191204184036946-433015830.png)

  最后使用CE添加这个基地址与偏移数据来验证一下，公式为 `[[[006A9F38+768]+AC]+58]]` 此时我们就可以定位到第一个太阳花的动态地址了。

  ![](/image/1379525-20191204184030549-305571865.png)

  根据上面的理论，我们知道太阳花的结构体大小为`14C`，那么我们在第一个太阳花动态地址的基础上加上14C就可以得到第二个太阳花的动态地址。

  ![](/image/1379525-20191204184016315-872542635.png)

  既然找到了基址与偏移，接下来就是通过C语言编程实现修改全图太阳花的冷却时间，此处贴出我实现的代码.

  ```C
  int main()
  {
	int base;
	int offset[4];
	int PID = 1292;
	base = 0x006a9f38;
	offset[0] = 0x768;
	offset[1] = 0xac;
	offset[2] = 0x58;
	int addr = GetDyAddr(PID, base, offset, 3);
	printf("阳光吐出动态地址：%x
  ", addr);
	HANDLE Process = OpenProcess(PROCESS_ALL_ACCESS, false, PID);
	int SunOffset = 0;
	int SunNum = 10;
	while (TRUE)
	{
		for (int i = 0; i < 5; i++)
		{
			WriteProcessMemory(Process, (LPVOID)(addr + SunOffset), &SunNum, 4, NULL);
			SunOffset = SunOffset + 0x14c;
			printf("搞事 fuck ok
  ");
		}
		SunOffset = 0;
		Sleep(1000);
	}
	return 0;
  }
  ```

  当我们进入游戏种植好太阳花以后，我们开启这个辅助，即可实现让前四个太阳花吐出阳光，最后种植的太阳花则不修改，为了防止程序出现假死我通过sleep函数让太阳花每一秒吐出一个阳光，这样修改的话会很有节奏感。

  ![](/image/1379525-20191204182924617-2006884566.png)

  上述方法，虽然可以修改达到无线吐阳光的作用，但是这种修改方式，显然是不太合理，如果图中有10个太阳花，那么我们则只能循环十次，这种效率还是太低，其实我们可以通过直接修改硬编码的方式来实现一劳永逸的效果，之所以是一劳永逸，是因为所有太阳花的吐阳光判断都是共用一个判断函数执行的，阳光的递减时钟都会走一个地方`add dword ptr [edi+58],-01` 我们只需要定位到这里，然后分析出阳光产生的关键键跳转并改掉其硬编码即可。

  ![](/image/1379525-20191204182914879-1844645757.png)

  上图是经过测试后备注的一些细节,我们只需要将图中的`0045FA7D`处的指令集,替换为nop即可实现全图的植物无线吐阳光啦,其C语言修改代码如下，代码中使用了上面封装好的的写内存字节集函数。

  ```C
  int main()
  {
	int PID = 3612;
	unsigned char Auto[] = { 0xEB };
	unsigned char Suns[] = { 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 };

	BOOL ret = WriteByteSet(PID, 0x0043158F, Auto, 1);
	BOOL ret1 = WriteByteSet(PID, 0x0045FA7D, Suns, 6);
	if (ret != 0 & ret1 != 0)
	{
		printf("您的向日葵已打包,请注意查收
  ");
	}
	return 0;
  }
  ```

  最终配合自动收集阳光，即可实现如下图所示的变态功能，其实这也不算变态，毕竟还有更加变态的，其实这种修改方式并不完美，因为我们的阳光数量可能是一个整数类型，如果不加以控制，当整数变量到达所能承载的最大范围时，则程序会发生整数溢出，轻则阳光变为负数，重则直接崩溃卡死。

  ![](/image/1379525-20191204182843747-1872771604.png)
